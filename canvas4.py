__author__ = 'David Owen'

import datetime
import html.parser
import json
import os.path
import random
import shutil
import sys
import urllib.parse
import urllib.request
import zipfile

from pdpm import pygmentize, run_pandoc, run_wkhtmltopdf
from canvas_token import TERM, SITE, TOKEN

TEMP = 'canvas4_py_temp'
        # Name to use for temporary files and directories.

PER_PAGE = 100
        # Max results to return from list URLs.

SHOW_UNPUBLISHED_COURSES = not False
        #

SHOW_ALL_ASSIGNMENTS = False
        # When prompting user for choice of assignment, show all
        # (not just those with ungraded submissions).

ALWAYS_MAKE_GRADE_FILE = False
        # When downloading (all) submissions, always create new
        # grades.txt (otherwise only creates new if grades.txt
        # doesn't exist).

PDFS_FOR_ALL = True
        # Create feedback PDFs for all students, even those who
        # didn't submit anything for the assignment.

MAX_ATTACHMENT_MB = 100
        # Max size for assignment submission attachment.

DELETE_ZIPS = True
        # When a zip file is submitted, delete it (after unzipping
        # and copying the contents to the original zip file's
        # folder).

ALL_FILES_IN_FEEDBACK_PDF = False
        # Rather than including one random source code sample in
        # feedback PDF, include all submitted source code files.

NO_FILES_IN_FEEDBACK_PDF = False
        # Rather than including one random source code sample in
        # feedback PDF, don't include any.

MOVE_PDFS_UP_DIR = True
        # Move PDFs up to directory from which this program is
        # run.

OVERWRITE_PDFS = True
        # Overwrite existing feedback PDFs when making new ones.

DEFAULT_EXTENSION_LIST = ['java', 'py', 'c', 'pde', 'jack', 'hdl']
        # If assignment attachment file types aren't restricted,
        # use this list instead of the assignment's (empty)
        # "allowed extensions" field.

EXCLUDED_EXTENSIONS = ['txt', 'zip', 'jpg', 'jpeg', 'png', 'docx',
        'mp3', 'tex', 'pdf']
        # These file types should not be considered when selecting
        # random source code sample to include in feedback file.

RECOGNIZED_SRC_EXTENSIONS = { '.py' : 'python', '.java': 'java',
        '.c' : 'c', '.pde' : 'processing' }
        # File extensions recognized as being source code.

FILES_TO_ALWAYS_SKIP = ['graphics.py', 'StdOut.java', 'StdIn.java',
        'StdAudio.java', 'StdStats.java', 'StdArrayIO.java',
        'StdDraw.java', 'AA_Tester.java', 'Draw.java',
        'DrawListener.java', 'In.java', 'Out.java',
        'Picture.java', 'ChordTest.java', 'ChordFun.java',
        'NoteTest.java', 'Note.java', 'OrangeWindowA.java',
        'OrangeWindowB.java', 'ComplexNumberTest.java',
        'MandelbrotVisualizationA.java', 'csapp.c', 'csapp.h']
        # Skip these files when choosing source code samples to
        # include in feedback file.

KEEP_FEEDBACK_MD = False
        # Don't delete Markdown (.txt) files created when
        # generating feedback PDFs.

TEST_RUNS_COMMENT = '<!-- test runs -->'
        # Placeholder for test run feedback in initial Markdown
        # version of feedback PDF.

TEST_RUNS_NOTE_COLOR = '0.6, 0.3, 0.1'  # (ignored by wkhtmltopdf)

USE_WKHTMLTOPDF = not True
        # Use pandoc to generate HTML, and then wkhtmltopdf to
        # generate PDF, for feedback PDFs.  (If False use pandoc
        # to generate PDF.)

WKHTMLTOPDF_HEADER = 'wkhtmltopdf_styles.txt'
        # Stuff to include in header of HTML file generated by
        # by pandoc and read by wkhtmltopdf (e.g., <style>...).

KEEP_FEEDBACK_HTML = False
        # Don't delete HTML files created when generating
        # feedback PDFs (using wkhtmltopdf).

NOTES_FILE = 'notes.txt'
        #

ESCAPE_BAD_CHARS = True
        #

QUIZ_TIME_LIMIT = 10
        #

DEFAULT_PTS_PER_QUIZ_QUESTION = 2
        #


def get_courses():
    """
    """

    url = '{}/api/v1/courses'.format(SITE)
    values = { 'enrollment_type' : 'teacher',
               'include[]'       : 'term',
               'per_page'        : PER_PAGE }

    data = urllib.parse.urlencode(values).encode('utf-8')
    request = urllib.request.Request(url, data, method='GET')
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())

    courses = []

    for course in response:
        if course['term']['name'] == TERM and \
                (SHOW_UNPUBLISHED_COURSES or
                (course['workflow_state'] == 'available')):
            courses.append(course)

    try:
        courses.sort(key=lambda course:
                str(9 - int(course['name'][-3])) +
                course['name'][-7:])

    except ValueError:
        # Will get here if one of the courses doesn't end with
        # course and section numbers.
        courses.sort(key=lambda course: course['name'])

    return courses


def prompt_for_course_id():
    """
    Prompt user to choose course (from per-term courses in the
    current term, as specified by TERM).

    :return: Canvas id of the course chosen by the user.
    """

    courses = get_courses()
    print()

    for i in range(len(courses)):
        print('{}. {} ({})'.format(i + 1, courses[i]['name'],
                courses[i]['term']['name']))

    i = int(input('\nCourse number? ')) - 1

    return str(courses[i]['id'])


def prompt_for_assignment(course_id):
    """
    Prompt user to choose assignment (from assignments in this
    course with submissions to grade, sorted by due date).

    :param course_id: Canvas id of course (as returned by
                      prompt_for_course_id).

    :return: dict version of Canvas object for assignment chosen
             by the user.
    """

    url = '{}/api/v1/courses/{}/assignments'.format(
            SITE, course_id)
    values = { 'per_page' : PER_PAGE }
    data = urllib.parse.urlencode(values).encode('utf-8')
    request = urllib.request.Request(url, data, method='GET')
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())

    assignments = []

    for assignment in response:
        if ('needs_grading_count' in assignment and \
                assignment['needs_grading_count'] > 0) or \
                (SHOW_ALL_ASSIGNMENTS and \
                not (assignment['due_at'] == None)):
            assignments.append(assignment)

    assignments.sort(key=lambda assignment: assignment['due_at'])
    print()

    for i in range(len(assignments)):
        print('{}. {}'.format(i + 1, assignments[i]['name']))

    i = int(input('\nAssignment number? ')) - 1
    print()

    return assignments[i]


def get_students(course_id):
    """
    Return dict mapping student ids to names, for all students
    enrolled in a course.  (Canvas won't allow teacher user to
    access other user profiles, so there's no way to get the
    names directly from the ids, or vice versa.)

    :param course_id: Canvas id of course (as returned by
                      prompt for course id).

    :return: dict mapping student ids to names.
    """

    url = '{}/api/v1/courses/{}/users'.format(SITE, course_id)
    values = { 'enrollment_type' : 'student',
               'per_page'        : PER_PAGE }
    data = urllib.parse.urlencode(values).encode('utf-8')
    request = urllib.request.Request(url, data, method='GET')
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())
    students = {}

    for student in response:

        #### Because he edited his sortable name...
        if student['sortable_name'] == '.Nathan Chan':
            student['sortable_name'] = 'Chan, Nathan'

        students[str(student['id'])] = student['sortable_name']

    return students


def prompt_for_student(course_id):
    """
    """

    students = get_students(course_id)
    students = sorted(students.items(),
            key=lambda student: student[1])

    for i in range(len(students)):
        print('{}. {}'.format(i + 1, students[i][1]))

    i = int(input('\nStudent number? ')) - 1
    print()

    return students[i]


def prompt_for_student_directory():
    """
    """

    print()
    student_dirs = []
    i = 1

    for d in sorted(os.listdir()):
        if '_' in d and os.path.isdir(d):
            print('{}. {}'.format(i, d))
            i += 1
            student_dirs.append(d)

    i = int(input('\nDirectory number? '))
    print()

    return student_dirs[i - 1]


def prompt_for_assignment_group_id(course_id):
    """
    """

    url = '{}/api/v1/courses/{}/assignment_groups'.format(SITE,
            course_id)
    request = urllib.request.Request(url, method='GET')
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())

    print()
    i = 1

    for group in response:
        print('{}. {}'.format(i, group['name']))
        i += 1

    i = int(input('\nGroup number? '))
    print()

    return response[i - 1]['id']


def check_discussions():
    """
    """

    for c in get_courses():
        print(c['name'])

        url = '{}/api/v1/courses/{}/discussion_topics'.format(
                SITE, c['id'])
        request = urllib.request.Request(url)
        request.add_header('Authorization', 'Bearer ' + TOKEN)
        response = urllib.request.urlopen(request)
        discussions = json.loads(response.read().decode())

        for d in discussions:
            print('    {:40} ({} unread)'.format(d['title'],
                    d['unread_count']))

        url = SITE + '/api/v1/announcements'
        values = { 'context_codes' : 'course_{}'.format(c['id']) }
        data = urllib.parse.urlencode(values).encode('utf-8')
        request = urllib.request.Request(url, data, method='GET')
        request.add_header('Authorization', 'Bearer ' + TOKEN)
        response = urllib.request.urlopen(request)
        announcements = json.loads(response.read().decode())

        for a in announcements:
            print('    {:40} ({} unread)'.format(a['title'],
                    a['unread_count']))


def unzip(filename, delete=False, copy_to_zip_dir=False):
    """
    Unzip a zip file.

    :param filename: name of zip file.
    :param delete: if True delete the original zip file.
    :param copy_to_zip_dir: if True copy all files to original
                            zip file's directory and delete
                            unzipped directory structure.
    """

    try:
        archive = zipfile.ZipFile(filename)

        if os.path.exists(TEMP):
            if os.path.isdir(TEMP):
                shutil.rmtree(TEMP)
            else:
                os.remove(TEMP)

        os.mkdir(TEMP)

        for name in archive.namelist():
            archive.extract(name, TEMP)

        archive.close()

        if delete:
            os.remove(filename)

        if copy_to_zip_dir:
            for path, dirs, files in os.walk(TEMP):
                for f in files:
                    shutil.copy(os.path.join(path, f), '.')

            shutil.rmtree(TEMP)

    except zipfile.BadZipFile:
        print('    FAILED TO UNZIP {} :(\n'.format(filename))


def download_attachment(attachment, student_name='?'):
    """
    Download Canvas attachment object's associated file (where
    attachment object comes from assignment submission object).
    If file is a zip file, will also unzip it, copy it's files
    to the original zip files directory, delete the zip file and
    delete the unzipped directory structure.

    :param attachment: Canvas attachment object associated with
                       file to download.
    :param student_name: name of student whose assignment
                         submission included the attachment
                         (optional, just for progress message).
    """

    filename = attachment['filename']
    print('Downloading {} ({})...'.format(filename, student_name))
    size = round(attachment['size'] / 1048576)

    if size > MAX_ATTACHMENT_MB:
        print('    TOO BIG! ({} MB)'.format(size))
    else:
        try:
            response = urllib.request.urlopen(attachment['url'])
            f = open(filename, 'wb')
            f.write(response.read())
            f.close()

            if filename.endswith('.zip'):
                unzip(filename, DELETE_ZIPS, True)

        except urllib.error.HTTPError:
            print('    DOWNLOAD FAILED :(')


def get_random_file(assignment, files_to_skip=False):
    """
    Get randomly selected source code file from assignment
    attachments.  (Or, if ALL_FILES_IN_FEEDBACK_PDF is True, get
    them all.  Or, if no suitable attachments, don't get any.)

    :assignment: Canvas assignment object, where the student's
                 assignment submission likely includes attached
                 source code files.
    :files_to_skip: specific file names to exclude when
                    considering attachments (i.e., starter files
                    included in assignment instructions).

    :return: list with zero or more filenames in it.
    """

    if 'allowed_extensions' in assignment:
        extension_list = assignment['allowed_extensions']

        for e in EXCLUDED_EXTENSIONS:
            if e in extension_list:
                extension_list.remove(e)
    else:
        extension_list = DEFAULT_EXTENSION_LIST

    if not files_to_skip:
        files_to_skip = FILES_TO_ALWAYS_SKIP
    else:
        files_to_skip += FILES_TO_ALWAYS_SKIP

    filenames = []
    m = os.listdir()

    #### For CIS 384 Chapter 3 Project...
    if os.path.exists('a'):
        m += os.listdir('a') + os.listdir('b')

    for filename in m:
        extension = filename[filename.rfind('.') + 1:].lower()

        if extension in extension_list and \
                not (filename in files_to_skip) and \
                not (filename.startswith('.')):
            filenames.append(filename)

    if len(filenames) > 0:
        if ALL_FILES_IN_FEEDBACK_PDF:
            filenames.sort()
        else:
            filenames = [random.choice(filenames)]

    return filenames


def download_submission(course_id, assignment, student_name,
        student_id, rubric_file=False, files_to_skip=False):
    """
    Download one student's assignment submission.  Create folder
    for the student if it doesn't exist.  Put submission
    attachments there.  If multiple attachments have the same
    file name, overwrite all but the last one submitted.  Also,
    create a markdown file with the assignment rubric and the
    content of one randomly chosen source code attachment file.
    (Or none, or all attached source code files...)

    :param course_id: Canvas id of course (as returned by
                      prompt_for_course_id).
    :param assignment: Canvas assignment object (as returned by
                       prompt_for_assignment).
    :param student_name: student's name (Canvas sortable name,
                         generally "Last, First"; value from
                         dict returned by get_students).
    :param student_id: Canvas id associated with student (value
                       from dict return by get_students).
    :param rubric_file: Markdown file with instructions and
                        grading rubric.  If unspecified, the
                        Markdown file generated for this
                        submission will just include a sample of
                        the student's submitted source code.
    :param files_to_skip: files to ignore if they show up as
                          attachements in student submissions
                          (i.e., starter files included in
                          assignment instructions).  If
                          unspecified, none of the student's
                          attached source code files will be
                          ignored.
    """

    if not student_id:
        students = get_students(course_id)

        for k, v in students.items():
            if v == student_name:
                student_id = k

    url = '{}/api/v1/courses/{}/assignments/{}'.format(
            SITE, course_id, assignment['id'])
    url += '/submissions/{}?include=submission_history'.format(
            student_id)
    request = urllib.request.Request(url)
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    submission = json.loads(response.read().decode())

    attachments = []
    late = False
    no_submission = False

    for submission in submission['submission_history']:
        if submission['late']:
            late = True

        if 'attachments' in submission:
            attachments += submission['attachments']

    if len(attachments) == 0:
        print('**** Nothing submitted by {}.'.format(student_name))
        no_submission = True

    if PDFS_FOR_ALL or len(attachments) > 0:
        # moss can't handle spaces in directory names...
        student_dir = student_name.replace(', ', '_').replace(
                ' ', '_')

        if not os.path.exists(student_dir):
            os.mkdir(student_dir)

        os.chdir(student_dir)

        for attachment in attachments:
            download_attachment(attachment, student_name)

        f = open('{} ({}).txt'.format(student_name,
                assignment['name']), 'w')

        if late:
            print('SUBMITTED LATE\n\n', file=f)
        elif PDFS_FOR_ALL and no_submission:
            print('NO SUBMISSION\n\n', file=f)

        print('## {}\n'.format(student_name), file=f)

        if rubric_file:
            print(open(os.path.join('..', rubric_file)).read(),
                    file=f)
        else:
            instructions = assignment['description'].replace(
                    '\r\n', '\n')
            print(instructions, file=f)

        print('\n' + TEST_RUNS_COMMENT, file=f)

        if not NO_FILES_IN_FEEDBACK_PDF:
            for filename in get_random_file(assignment,
                    files_to_skip):

                try:
                    src = open(filename).read().strip()
                except UnicodeDecodeError:
                    src = open(filename,
                            encoding='latin-1').read().strip()
                    src = src.encode('ascii', 'replace').decode()

                src = src.replace('\t', '    ')

                if ESCAPE_BAD_CHARS:
                    src = src.replace('%', '\\%')
                    # src = src.replace('>', '\\&gt;')
                    # src = src.replace('>', '\\textgreater')
                    src = src.replace('&', '\\&')

                lang = ''

                for k, v in RECOGNIZED_SRC_EXTENSIONS.items():
                    if filename.endswith(k):
                        lang = v

                print('\n### Sample File\n\n({})\n'.format(
                        filename), file=f)
                print('~~~{}'.format(lang), file=f)
                print(src, file=f)
                print('~~~', file=f)

        f.close()
        os.chdir('..')


def download_all(rubric_file=False, files_to_skip=False):
    """
    Prompt user to choose course, and then to choose an
    assignment from those within the course that have ungraded
    submissions.  Then run download_submission for the chosen
    assignment, for all students within the course.

    :rubric_file: passed directly to download_submission...
    :files_to_skip: passed directly to download_submission...
    """

    course_id = prompt_for_course_id()
    assignment = prompt_for_assignment(course_id)
    students = get_students(course_id)
    make_grade_file = ALWAYS_MAKE_GRADE_FILE or \
            not os.path.exists('grades.txt')

    if make_grade_file:
        grade_file = open('grades.txt', 'w')
        print('{', file=grade_file)

    for student in sorted(students.items(),
            key=lambda student: student[1]):
        download_submission(course_id, assignment, student[1],
                student[0], rubric_file, files_to_skip)

        if make_grade_file:
            print("    {0:20} : ,".format("'" + student[1] + "'"),
                    file=grade_file)

    if make_grade_file:
        print('}', file=grade_file)
        grade_file.close()


def get_notes(d, notes):
    """
    """

    n = ''
    k = list(notes[d].keys())

    try:
        def exercise_number(f):
            i = f.find('e')

            if i == 2 or i == 3:
                return "{:03}".format(int(f[i + 1:f.find('_')]))
            else:
                return '000' + f

        k.sort(key=exercise_number)

    except ValueError:
        k.sort()

    for f in k:
        if '*' in notes[d][f]:
            j = notes[d][f].rfind('*')
            i = notes[d][f].rfind('*', 0, j - 1) + 1

            while notes[d][f][i - 1] == '\\':
                i = notes[d][f].rfind('*', 0, i - 1) + 1

            c = notes[d][f][i:j]

            if ESCAPE_BAD_CHARS:
                c = c.replace('_', '\\_')
                f = f.replace('_', '\\_')

            if USE_WKHTMLTOPDF:
                n += '<div class="test_run_comment">' + \
                        '{} – {}</div>\n'.format(f, c)
            else:
                n += '\\textsf{\\textit{\\color[rgb]{' + \
                        TEST_RUNS_NOTE_COLOR + '} ' + \
                        f + ' – ' + c + '\\\\}}\n'

    if n == '':
        n = '\\textsf{\\textit{\\color[rgb]{' + \
                TEST_RUNS_NOTE_COLOR + '} ' + \
                '(Everything looks good.)\\\\}}\n'

    if ESCAPE_BAD_CHARS:
        n = n.replace('%', '\\%')
        # n = n.replace('>', '\\&gt;')
        # n = n.replace('>', '\\textgreater')
        n = n.replace('&', '\\&')

    return n


def make_feedback_pdf(d, notes=False):
    """
    """

    os.chdir(d)
    last_name = d[:d.find('_')]

    for f in os.listdir():
        if f.startswith(last_name) and f.endswith('.txt'):
            print('Making feedback pdf ({})...'.format(
                    f[:f.rfind('.')]))

            if not '_notes.txt' in f:
                if USE_WKHTMLTOPDF:
                    pg, style_defs = pygmentize(f, 'html')
                else:
                    pg, style_defs = pygmentize(f, 'pdf')

                # if NOTES_FILE and notes and (d in notes):
                if notes and (d in notes):
                    pg = pg.replace(TEST_RUNS_COMMENT,
                            '### Notes From Test Runs\n\n' +
                            get_notes(d, notes))

                t = open(TEMP, 'w')
                print(pg, file=t)
                t.close()
            else:
                # Weird hack to get style_defs :(
                if USE_WKHTMLTOPDF:
                    pg, style_defs = pygmentize(
                            f.replace('_notes.txt', '.txt'), 'html')
                else:
                    pg, style_defs = pygmentize(
                            f.replace('_notes.txt', '.txt'), 'pdf')

                shutil.copy(f, TEMP)

            if USE_WKHTMLTOPDF:
                g = f.replace('.txt', '.html')

                if WKHTMLTOPDF_HEADER:
                    # p = '../' + os.path.dirname(__file__) + '/'
                    p = os.path.dirname(__file__) + '/'
                    w = '-H ' + p + WKHTMLTOPDF_HEADER
                else:
                    w = ''

                run_pandoc(TEMP, g, 'html', False,
                        style_defs, w)
                run_wkhtmltopdf(g)

                if not KEEP_FEEDBACK_HTML:
                    os.remove(g)
            else:
                run_pandoc(TEMP, f.replace('.txt', '.pdf'),
                        'pdf', False, style_defs)

            if KEEP_FEEDBACK_MD and not os.path.exists(
                        f.replace('.txt', '_notes.txt')) and \
                        not '_notes.txt' in f:
                shutil.copy(TEMP, f.replace('.txt', '_notes.txt'))
            elif not KEEP_FEEDBACK_MD:
                os.remove(f)

            os.remove(TEMP)

            if MOVE_PDFS_UP_DIR:
                g = f.replace('.txt', '.pdf')

                if OVERWRITE_PDFS and \
                        os.path.exists('../' + g):
                    os.remove('../' + g)

                shutil.move(f.replace('.txt', '.pdf'),
                        '..')

    os.chdir('..')


def make_feedback_pdfs():
    """
    """

    print()
    notes = False

    if NOTES_FILE:
        try:
            notes = eval(open(NOTES_FILE).read())
        except FileNotFoundError:
            pass

    for d in sorted(os.listdir()):
        if '_' in d and os.path.isdir(d):
            make_feedback_pdf(d, notes)


def upload(filename, url, folder=False, timestamp_folder=False):
    """
    Upload a file to Canvas.  File type will be guessed (by Canvas
    server) based on extension.  Canvas API documentation
    specifies URLs for places you can upload files; within one of
    those places you can specify a folder where the file should
    go.

    :return: Canvas id of uploaded file.
    """

    basename = os.path.basename(filename)
    values = { 'name' : basename }

    if folder:
        values['parent_folder_path'] = folder

        if timestamp_folder:
            d = datetime.datetime.now()
            folder += '/{}-{:02}-{:02}'.format(d.year, d.month,
                    d.day)
            folder += 'T{:02}:{:02}:{:02}'.format(d.year,
                    d.minute, d.second)
            folder += '_' + basename

    data = urllib.parse.urlencode(values).encode('utf-8')
    request = urllib.request.Request(url, data)
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())

    boundary = 'y30Wa3qB34St138Z'  # Just a random string.
    lines = []

    for key, value in response['upload_params'].items():
        lines.append('--' + boundary)
        lines.append(
                'Content-Disposition: form-data; name="{}"'.format(
                key))
        lines.append('')
        lines.append(value)

    lines.append('--' + boundary)
    lines.append('Content-Disposition: form-data; name="file"; ' +
            'filename="{}"'.format(filename))
    lines.append('')
    lines.append('')
    body = '\r\n'.join(lines).encode('utf-8')
    body += open(filename, 'rb').read()
    body += '\r\n--{}--\r\n'.format(boundary).encode('utf-8')

    request = urllib.request.Request(response['upload_url'],
            body)
    request.add_header('Content-Type',
            'multipart/form-data; boundary=' + boundary)
    request.add_header('Content-Length', str(len(body)))
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())

    return response['id']


def upload_feedback(course_id, assignment, student_name,
        student_id, grade=False):
    """
    Requires Python 3.3+ version of urllib.request.
    """

    filename = '{} ({}).pdf'.format(student_name,
            assignment['name'])

    if os.path.exists(filename):
        print('Uploading feedback PDF ({})...'.format(
                student_name))
        url = '{}/api/v1/courses/{}/assignments/{}/submissions/{}'.format(
                SITE, course_id, assignment['id'], student_id)
        file_id = upload(filename, url + '/comments/files')
        comment = 'See attached PDF for comments on your assignment.'
        values = { 'comment[text_comment]' : comment,
                   'comment[file_ids]'     : file_id }

        if grade:
            values['submission[posted_grade]'] = grade

        data = urllib.parse.urlencode(values).encode('utf-8')
        request = urllib.request.Request(url, data, method='PUT')
        request.add_header('Authorization', 'Bearer ' + TOKEN)
        urllib.request.urlopen(request)


def upload_all():
    """
    """

    course_id = prompt_for_course_id()
    assignment = prompt_for_assignment(course_id)
    students = get_students(course_id)
    grades = eval(open('grades.txt').read())

    for student in sorted(students.items(),
            key=lambda student: student[1]):
        if (student[1] in grades):
            upload_feedback(course_id, assignment, student[1],
                    student[0], grades[student[1]])


def new_page(filename, slides=False):
    """
    """

    course_id = prompt_for_course_id()
    md = open(filename).read()

    if filename.endswith('.txt'):
        first_line = md[:md.find('\n')]

        if first_line.startswith('#'):
            title = first_line.replace('#', '').strip()
            md = md[md.find('\n') + 1:]
        else:
            title = os.path.basename(filename)
            title = title[:title.rfind('.')]
            title = title.replace('_', ' ')
            title = title.replace('-', ' ').title()

        if slides:
            pg, style_defs = pygmentize(md, 'html', False)
            t = open(TEMP, 'w')
            print(pg, file=t)
            t.close()

            slides_filename = filename[:filename.rfind('.')] + \
                    '_slides.html'
            run_pandoc(TEMP, slides_filename, 'slides', True,
                    style_defs)
            url = '{}/api/v1/courses/{}/files'.format(SITE,
                    course_id)
            file_id = upload(slides_filename, url, 'slides')
            slides_url = '{}/courses/{}/files/{}/download'.format(
                    SITE, course_id, file_id)
            md = '(As slides: [{}]({}))\n\n'.format(
                    os.path.basename(slides_filename),
                    slides_url) + md

        pg, style_defs = pygmentize(md, 'html', False)

    else:  # Assume file is a source code example.
        url = '{}/api/v1/courses/{}/files'.format(SITE, course_id)
        file_id = upload(filename, url, 'examples', True)
        file_url = '{}/courses/{}/files/{}/download'.format(
                SITE, course_id, file_id)
        title = os.path.basename(filename)
        ext = title[title.rfind('.') + 1:]
        pg, style_defs = pygmentize(md, 'html', False, ext)
        pg = '(As plain text: [{}]({}))\n\n'.format(
                title, file_url) + pg

    # Check for existing page with the same title.  If so,
    # update it.  (Any files associated with the old version
    # of the page will be left alone.)
    url = '{}/api/v1/courses/{}/pages'.format(SITE, course_id)
    values = { 'per_page' : PER_PAGE }
    data = urllib.parse.urlencode(values).encode('utf-8')
    request = urllib.request.Request(url, data, method='GET')
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())
    update = False

    for page in response:
        if page['title'].lower().replace(' ', '') == \
                title.lower().replace(' ', ''):
            page_url = page['url']
            update = True

    f = open(TEMP, 'w')
    print(pg, file=f)
    f.close()
    run_pandoc(TEMP, TEMP + '.html', 'html', True, style_defs)
    ht = open(TEMP + '.html').read()
    os.remove(TEMP)
    os.remove(TEMP + '.html')

    values = { 'wiki_page[title]' : title,
               'wiki_page[body]'  : ht }
    data = urllib.parse.urlencode(values).encode('utf-8')

    if update:
        request = urllib.request.Request('{}/{}'.format(
                url, page_url), data, method='PUT')
    else:
        request = urllib.request.Request(url, data)

    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    
    if input('Create event? ') != '':
        response = json.loads(response.read().decode())
        description = \
                '<a href="/courses/{}/pages/{}">{}</a>'.format(
                course_id, response['url'], title)
        new_event(course_id, title, description)


def new_assignment(filename):
    """
    """

    course_id = prompt_for_course_id()
    group_id = prompt_for_assignment_group_id(course_id)
    title = input('Title? (from file): ')
    md = open(filename).read()

    if title == '':
        first_line = md[:md.find('\n')]

        if first_line.startswith('#'):
            title = first_line.replace('#', '').strip()
            md = md[md.find('\n') + 1:]
        else:
            title = os.path.basename(filename)
            title = title[:title.rfind('.')]
            title = title.replace('_', ' ')
            title = title.replace('-', ' ').title()

    pg, style_defs = pygmentize(md, 'html', False)
    f = open(TEMP, 'w')
    print(pg, file=f)
    f.close()
    run_pandoc(TEMP, TEMP + '.html', 'html', True, style_defs)
    ht = open(TEMP + '.html').read()
    os.remove(TEMP)
    os.remove(TEMP + '.html')

    due_at = input('Date due? (YYYY-MM-DD) (blank): ')
    due_at += 'T' + input('Time? (24-hr HH:MM) (blank): ') + ':00'
    pts = input('Points (blank): ')

    if pts == '' or pts == '0':
        pts = False
    else:
        pts = int(pts)

    exts = input('File upload extenstions? (blank): ')

    # Check for existing assignment with the same title.  If so,
    # update it instead of creating a new assignment.
    url = '{}/api/v1/courses/{}/assignments'.format(SITE,
            course_id)
    values = { 'per_page' : PER_PAGE }
    data = urllib.parse.urlencode(values).encode('utf-8')
    request = urllib.request.Request(url, data, method='GET')
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())
    update = False

    for assignment in response:
        if assignment['name'] == title:
            assignment_id = assignment['id']
            update = True

    # Use unlock_at field to record the time the assigment was
    # uploaded to Canvas, since there's no created_at field.
    d = datetime.datetime.now()
    unlock_at = '{}-{:02}-{:02}T{:02}:{:02}:00'.format(
            d.year, d.month, d.day, d.hour, d.minute)
    url = '{}/api/v1/courses/{}/assignments'.format(
            SITE, course_id)
    values = { 'assignment[assignment_group_id]' : group_id,
               'assignment[name]'                : title,
               'assignment[description]'         : ht,
               'assignment[unlock_at]'           : unlock_at }

    if pts:
        values['assignment[grading_type]'] = 'points'
        values['assignment[points_possible]'] = pts

    if due_at != 'T:00':
        values['assignment[due_at]'] = due_at

    if exts != '':
        values['assignment[submission_types]'] = 'online_upload'

        if not 'zip' in exts:
            exts += ',zip'

        values['assignment[allowed_extensions]'] = exts
    elif pts:
        values['assignment[submission_types]'] = 'on_paper'
    elif not update:
        values['assignment[submission_types]'] = 'none'

    data = urllib.parse.urlencode(values).encode('utf-8')

    if update:
        request = urllib.request.Request('{}/{}'.format(url,
                assignment_id), data, method='PUT')
    else:
        request = urllib.request.Request(url, data)

    request.add_header('Authorization', 'Bearer ' + TOKEN)
    urllib.request.urlopen(request)


def new_event(course_id, title, description):
    """
    """

    date = input('Date? (YYYY-MM-DD) (blank): ')

    if date != '':
        start_at = input('Start? (24-hr HH:MM) (blank): ')

        if start_at != '':
            end_at = input('End? (24-hr HH:MM) (start + 1 hr): ')

            if end_at == '':
                end_at = str(int(start_at[:2]) + 1) + start_at[2:]

            start_at = date + 'T' + start_at + ':00'
            end_at = date + 'T' + end_at + ':00'

    # Check for existing event with the same title.  If so,
    # update it instead of creating a new event.
    url = '{}/api/v1/calendar_events'.format(SITE)
    values = { 'per_page'   : PER_PAGE,
               'undated'    : True,
               'all_events' : True,
               'context_codes[]' : 'course_' + course_id }
    data = urllib.parse.urlencode(values).encode('utf-8')
    request = urllib.request.Request(url, data, method='GET')
    request.add_header('Authorization', 'Bearer ' + TOKEN)
    response = urllib.request.urlopen(request)
    response = json.loads(response.read().decode())
    update = False

    for event in response:
        if event['title'] == title:
            event_id = event['id']
            update = True

    d = datetime.datetime.now()
    created_at = '{}-{:02}-{:02}T{:02}:{:02}:00'.format(
            d.year, d.month, d.day, d.hour, d.minute)
    url = '{}/api/v1/calendar_events'.format(SITE)
    values = { 'calendar_event[context_code]' : 'course_' + course_id,
               'calendar_event[title]'        : title,
               'calendar_event[description]'  : description,
               'calendar_event[created_at]'   : created_at }

    if date != '':
        if start_at != '':
            values['calendar_event[start_at]'] = start_at
            values['calendar_event[end_at]'] = end_at
        elif not update:
            values['calendar_event[start_at]'] = date + 'T08:00:00'
            values['calendar_event[end_at]'] = date + 'T08:00:00'
            values['calendar_event[all_day_date]'] = date
            values['calendar_event[all_day]'] = True

    data = urllib.parse.urlencode(values).encode('utf-8')

    if update:
        request = urllib.request.Request('{}/{}'.format(url,
                event_id), data, method='PUT')
    else:
        request = urllib.request.Request(url, data)

    request.add_header('Authorization', 'Bearer ' + TOKEN)
    urllib.request.urlopen(request)



def new_event_from_file(filename):
    """
    """

    course_id = prompt_for_course_id()
    title = input('Title? (from file): ')
    md = open(filename).read()

    if title == '':
        first_line = md[:md.find('\n')]

        if first_line.startswith('#'):
            title = first_line.replace('#', '').strip()
            md = md[md.find('\n') + 1:]
        else:
            title = os.path.basename(filename)
            title = title[:title.rfind('.')]
            title = title.replace('_', ' ')
            title = title.replace('-', ' ').title()

    pg, style_defs = pygmentize(md, 'html', False)
    f = open(TEMP, 'w')
    print(pg, file=f)
    f.close()
    run_pandoc(TEMP, TEMP + '.html', 'html', True, style_defs)
    description = open(TEMP + '.html').read()
    os.remove(TEMP)
    os.remove(TEMP + '.html')

    new_event(course_id, title, description)


class QuizParser(html.parser.HTMLParser):

    def __init__(self):
        super(QuizParser, self).__init__(convert_charrefs=True)
        self.keep = ''
        self.in_questions = False
        self.in_question_set = False
        self.in_mc_answers = False

    def handle_starttag(self, tag, attrs):

        if tag == 'h2':
            self.keep = ''

        elif tag == 'ol':
            if not self.in_questions:
                self.in_questions = True
            elif self.in_question_set:
                url = '{}/api/v1/courses/{}/quizzes/{}/questions/'.format(
                        SITE, self.course_id, self.quiz_id)
                values = {
                        'question[question_text]' : self.keep,
                        'question[question_type]' :
                            'text_only_question' }
                data = urllib.parse.urlencode(values).encode(
                        'utf-8')
                request = urllib.request.Request(url, data, \
                        method='POST')
                request.add_header('Authorization',
                        'Bearer ' + TOKEN)
                urllib.request.urlopen(request)

                self.keep = ''

            else:
                self.in_mc_answers = True
                p = self.get_points()
                        # Also strips '(_ pts)' from self.keep.

                self.values = {
                        'question[question_text]'   : self.keep,
                        'question[question_type]'   :
                            'multiple_choice_question',
                        'question[points_possible]' : p }
                self.answer_index = 0

                self.keep = ''

        elif tag != 'li':
            self.keep += '<' + tag

            for a in attrs:
                self.keep += ' {}="{}"'.format(a[0], a[1])

            self.keep += '>'

    def handle_endtag(self, tag):

        if tag == 'h2':
            self.course_id = prompt_for_course_id()

            url = '{}/api/v1/courses/{}/quizzes/'.format(
                    SITE, self.course_id)
            values = { 'quiz[title]'      : self.keep,
                       'quiz[quiz_type]'  : 'assignment',
                       'quit[time_limit]' : QUIZ_TIME_LIMIT }
            data = urllib.parse.urlencode(values).encode('utf-8')
            request = urllib.request.Request(url, data,
                    method='POST')
            request.add_header('Authorization',
                    'Bearer ' + TOKEN)
            response = urllib.request.urlopen(request)
            response = json.loads(response.read().decode())
            self.quiz_id = str(response['id'])

            self.keep = ''

        elif tag == 'ol':
            if self.in_mc_answers:
                self.in_mc_answers = False

                url = '{}/api/v1/courses/{}/quizzes/{}/questions/'.format(
                        SITE, self.course_id, self.quiz_id)
                data = urllib.parse.urlencode(self.values).encode(
                        'utf-8')
                request = urllib.request.Request(url, data,
                        method='POST')
                request.add_header('Authorization',
                        'Bearer ' + TOKEN)
                urllib.request.urlopen(request)

            elif self.in_question_set:
                self.in_question_set = False

            else:
                # Extra PUT makes Canvas update total points and
                # number of questions.
                url = '{}/api/v1/courses/{}/quizzes/{}'.format(
                        SITE, self.course_id, self.quiz_id)
                values = { 'quiz[time_limit]' : QUIZ_TIME_LIMIT }
                data = urllib.parse.urlencode(values).encode(
                        'utf-8')
                request = urllib.request.Request(url, data,
                        method='PUT')
                request.add_header('Authorization',
                        'Bearer ' + TOKEN)
                urllib.request.urlopen(request)

        elif tag == 'li':
            if self.in_mc_answers:
                self.values['question[ansers][{}][html]'.format(
                        self.answer_index)] = self.keep + '&nbsp;'
                self.answer_index += 1

                self.keep = ''
            elif len(self.keep.strip()) > 0:
                p = self.get_points()

                if 'True or False' in self.keep:
                    url = '{}/api/v1/courses/{}/quizzes/{}/questions/'.format(
                            SITE, self.course_id, self.quiz_id)
                    values = { 'question[question_text]'    : \
                                   self.keep,
                               'question[question_type]'    : \
                                   'multiple_choice_question',
                               'question[points_possible]'  : p,
                               'question[answers][0][html]' : \
                                   '<p>True</p>',
                               'question[answers][1][html]' : \
                                   '<p>False</p>' }
                    data = urllib.parse.urlencode(values).encode(
                            'utf-8')
                    request = urllib.request.Request(url, data,
                            method='POST')
                    request.add_header('Authorization',
                            'Bearer ' + TOKEN)
                    urllib.request.urlopen(request)

                else:
                    url = '{}/api/v1/courses/{}/quizzes/{}/questions/'.format(
                            SITE, self.course_id, self.quiz_id)
                    values = { 'question[question_text]'   : \
                                   self.keep,
                               'question[question_type]'   : \
                                   'essay_question',
                               'question[points_possible]' : p }
                    data = urllib.parse.urlencode(values).encode(
                            'utf-8')
                    request = urllib.request.Request(url, data,
                            method='POST')
                    request.add_header('Authorization',
                            'Bearer ' + TOKEN)
                    urllib.request.urlopen(request)

                self.keep = ''

        else:
            self.keep += '</' + tag + '>'

    def handle_data(self, data):
        self.keep += data

    def handle_comment(self, data):

        if 'set' in data:
            self.in_question_set = True

    def get_points(self):
        i = self.keep.find(' pts)')

        if i == -1:
            return DEFAULT_POINTS

        else:
            j = self.keep.rfind('(', 0, i)
            p = int(self.keep[(j + 1):i])
            self.keep = self.keep[:j] + self.keep[(i + 5):]

            return p


if __name__ == '__main__':

    if sys.argv[1] == '-da':
        if len(sys.argv) == 2:
            download_all()
        elif len(sys.argv) == 3:
            download_all(sys.argv[2])
        else:
            download_all(sys.argv[2], eval(sys.argv[3]))

    elif sys.argv[1] == '-d':
        course_id = prompt_for_course_id()
        assignment = prompt_for_assignment(course_id)
        student = prompt_for_student(course_id)

        if len(sys.argv) == 2:
            download_submission(course_id, assignment, student[1],
                    student[0])
        elif len(sys.argv) == 3:
            download_submission(course_id, assignment, student[1],
                    student[0], sys.argv[2])
        elif len(sys.argv) == 4:
            download_submission(course_id, assignment, student[1],
                    student[0], sys.argv[2], eval(sys.argv[3]))
        else:
            download_submission(course_id, assignment,
                    sys.argv[2], False, sys.argv[3],
                    eval(sys.argv[4]))

    elif sys.argv[1] == '-fa':
        make_feedback_pdfs()

    elif sys.argv[1] == '-f':
        notes = False

        if NOTES_FILE:
            try:
                notes = eval(open(NOTES_FILE).read())
            except FileNotFoundError:
                pass

        make_feedback_pdf(prompt_for_student_directory(), notes)

    elif sys.argv[1] == '-ua':
        upload_all()

    elif sys.argv[1] == '-u':
        course_id = prompt_for_course_id()
        assignment = prompt_for_assignment(course_id)
        student = prompt_for_student(course_id)
        grade = False

        if os.path.exists('grades.txt'):
            try:
                grades = eval(open('grades.txt').read())
                grade = grades[student[1]]
            except SyntaxError:
                pass

        upload_feedback(course_id, assignment, student[1],
                student[0], grade)

    elif sys.argv[1] == '-p':
        new_page(sys.argv[2])

    elif sys.argv[1] == '-ps':
        new_page(sys.argv[2], slides=True)

    elif sys.argv[1] == '-a':
        new_assignment(sys.argv[2])

    elif sys.argv[1] == '-q':
        p = QuizParser()
        p.feed(open(sys.argv[2]).read())

    elif sys.argv[1] == '-c':
        check_discussions()

    elif sys.argv[1] == '-e':
        new_event_from_file(sys.argv[2])

    elif len(sys.argv) > 1:
        print("I don't understand {} :(".format(sys.argv[1]))
    else:
        print('I need a command-line argument :(')

    print()
